/*
 * rs232_buffer.c
 *
 *  Created on: 5 окт. 2017 г.
 *      Author: dmsvo
 */

#include "rs232_buffer.h"

/* Вспомогательная функция по переводу 16-цифры в ASCII */
char hexToChar(char hex)
{
	if ((hex >= 0) && (hex <= 9))
		return 0x30 + hex;

	if ((hex >=10) && (hex <= 15))
		return 0x37 + hex; /* с 41го символа начинается A, B, ... , F; 0x41 - 0xA = 0x37*/

	return 0;	/* если нам почему-то не подошло. Возможно, имеет смысл в таком случае возвращать -1 */
}

/*
 * Функция принимает необходимые числа и составляет буфер по правилам протокола Искра
 * формат сообщения - список полей
 * наименование - размер
 * SOH - 1 байт - маркер начала
 * + TRK_No - 2 байта - номер ТРК
 * + Command - 1 байт - код команды управления
 * STX - 1 байт - маркер начала поля данных
 * + Price 6 - байт - цена топлива, коп
 * + Volume - 6 байт - доза налива
 * Status - 4 байта - код состояния/ошибки
 * ETX - 1 байт - маркер окончания поля данных
 * CRC - 1 байт - контрольная сумма
 * всего - 23 байта
 */
int fill_buffer (uint8* buf, struct Message msg)
{
	/*
	 * Проверка на то, что значения параметров в заданных границах
	 */
	if (msg.trkNo > 127) return FSTATUS_BOUND;
	if (msg.command < 1 || msg.command > 9 || msg.command == 2 || msg.command == 8) return FSTATUS_BOUND;
		/* дополнительно проверка на исключённые из протокола команды 2 и 8.
		 * Надо ли? Не могу сказать точно, не имея представления об эксплуатационной практике */
	if (msg.price > 999999 || msg.price < 0) return FSTATUS_BOUND;
	if (msg.volume > 999999 || msg.price < 0) return FSTATUS_BOUND;

	/*
	 * Тут должны быть дополнительные проверки для обеспечения корректности параметров для всех специальных случаев.
	 * Для примера, приведена проверка на наличие поля статуса для команды #3 ("Установка") (- предполагаем, что
	 * для данной команды в этом поле должно быть хоть что-то, чтобы команда отработала)
	 * и проверка на равенство 0 объёма дозы для команды #9 ("До полного бака") (- предполагаем, что это значение
	 * так же передаётся как входной параметр, а не должно игнорироваться и заменяться нулями принудительно).
	 * Если что не так, возвращаем код ошибки
	 */
	if (msg.command == 3 /* установка параметров */
		&& msg.status == 0) return FSTATUS_WRONGSPC;

	if (msg.command == 9 /* установка параметров */
		&& msg.volume != 0) return FSTATUS_WRONGSPC;

	/*
	 * Запись параметров в буфер
	 */

	/* вспомогательный указатель */
	uint8* ptr = buf;

	/* маркер начала сообщения */
	*ptr = 0x1; ptr++;

	/* номер ТРК */
	*ptr = hexToChar(msg.trkNo / 16);
	int crc = *ptr; ptr++;
	*ptr = hexToChar(msg.trkNo % 16);
	crc ^= *ptr; ptr++;

	/* код команды управления */
	*ptr = hexToChar(msg.command);
	crc ^= *ptr; ptr++;

	/* маркер начала поля данных */
	*ptr = 0x2;
	crc ^= *ptr; ptr++;

	/* цена топлива */
	int tmp = msg.price;
	for (int i = 0; i < 6; i++)
	{
		ptr[5-i] = hexToChar(tmp%10); /* переводим число в ascii в обратном порядке для лаконичности */
		crc ^= ptr[5-i];
		tmp = tmp / 10;
	}
	ptr += 6;

	/* объём дозы */
	tmp = msg.volume;
	for (int i = 0; i < 6; i++)
	{
		ptr[5-i] = hexToChar(tmp%10); /* переводим число в ascii в обратном порядке для лаконичности */
		crc ^= ptr[5-i];
		tmp = tmp / 10;
	}
	ptr += 6;

	/* поле статуса. Может использоваться при передачах от ККМ к ТРК */
	tmp = msg.status;
	for (int i = 0; i < 4; i++)
	{
		ptr[3-i] = hexToChar(tmp%16);
		crc ^= ptr[3-i];
		tmp = tmp / 16;
	}
	ptr += 4;	/* 4 байта для кода статуса от ТРК */

	/* маркер окончания поля данных */
	*ptr = 0x3;
	crc ^= *ptr; ptr++;

	/* проверка контрольной суммы */
	*ptr = crc;

	return FSTATUS_OK;
}
