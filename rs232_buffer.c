/*
 * rs232_buffer.c
 *
 *  Created on: 5 окт. 2017 г.
 *      Author: dmsvo
 */

#include "rs232_buffer.h"

/* Вспомогательная функция по переводу цифры в ASCII. Подходит для цифр с основанием не больше 16.
 * Поскольку цифру в буквенный код всегда можно перевести, никаких кодов ошибки не предполагаем,
 * для удобства результат возвращаем как положено, а не через входные аргументы.
 * Если на вход поступает число, а не цифра, берём от него строго последнюю (ну, в смысле, первую) цифру в данном основании. */
char digToChar(int num, char base)
{
	/* убеждаемся, что перед нами строго цифра */
	char dig = num % base;

	if ((dig >= 0) && (dig <= 9))
	{
		return NUM0 + dig;
	}

	if ((dig >=10) && (dig <= 15))
	{
		return DIFA + dig; /* с 41го символа начинается A, B, ... , F; 0x41 - 0xA = 0x37*/
	}

	return FSTATUS_NOTDIGIT;	/* если каким-то образом нам не подошло */
}

/* Макрос для записи числа в буфер.
 * Для разнообразия, выполнено в виде макроса, а не функции.
 * Переводим число в ascii в обратном порядке для сравнительной лаконичности преобразования
 * _var - число, которое хотим записать в буфер
 * _tmp - промежуточная переменная типа unsigned int, объявляемая снаружи
 * _len - количество бит, выделяемых под переменную в буфере
 * _ptr - указатель на ячейку буфера, начиная с которой следует записывать число
 * _crc - переменная для подсчёта контрольной суммы в процессе записи
 * _base - основание числа для представления его в буфере. Отличается для разных полей (10 или 16)
 */
#define WRITE_TO_BUF(_var, _tmp, _len, _ptr, _crc, _base)		\
{													\
	(_tmp) = (_var);								\
	for (int i = 0; i < (_len); i++)				\
	{												\
		(_ptr)[(_len)-i-1] = digToChar((_tmp),(_base)); 	\
		(_crc) ^= (_ptr)[(_len)-i-1];				\
		(_tmp) = (_tmp) / (_base);						\
	}												\
	(_ptr) += (_len);								\
}


/*
 * Функция принимает необходимые числа и составляет буфер по правилам протокола Искра.
 * формат сообщения (список полей):
 * (наименование - размер - комментарий. Плюсами отмечены те, которые передаются в качестве входных данных)
 * SOH - 1 байт - маркер начала
 * + TRK_No - 2 байта - номер ТРК
 * + Command - 1 байт - код команды управления
 * STX - 1 байт - маркер начала поля данных
 * + Price 6 - байт - цена топлива, коп
 * + Volume - 6 байт - доза налива
 * + Status - 4 байта - код состояния/ошибки
 * ETX - 1 байт - маркер окончания поля данных
 * CRC - 1 байт - контрольная сумма
 * всего - 23 байта
 */
int fill_buffer (uint8* buf, struct Message msg)
{
	/*
	 * Проверка на то, что значения параметров в заданных границах.
	 * Получить значения меньше нуля очень сложно, потому что типы полей структуры мы указали беззнаковыми,
	 * но на всякий случай себя обезопасим, если определение структуры изменится
	 */
	if (msg.trkNo > MAX_TRKNO || msg.trkNo < 0) return FSTATUS_BOUND;
	if (msg.command < 0 || msg.command > MAX_COM || msg.command == 2 || msg.command == 8) return FSTATUS_BOUND;
		/* дополнительно проверка на исключённые из протокола команды 2 и 8.
		 * Надо ли? Не могу сказать точно, не имея представления об эксплуатационной практике */
	if (msg.price > MAX_PRC || msg.price < 0) return FSTATUS_BOUND;
	if (msg.volume > MAX_VOL || msg.price < 0) return FSTATUS_BOUND;

	/*
	 * Тут должны быть дополнительные проверки для обеспечения корректности параметров для всех специальных случаев.
	 * Для примера, приведена проверка на наличие поля статуса для команды #3 ("Установка") (- предполагаем, что
	 * для данной команды в этом поле должно быть хоть что-то, чтобы команда отработала)
	 * и проверка на равенство 0 объёма дозы для команды #9 ("До полного бака") (- предполагаем, что это значение
	 * так же передаётся как входной параметр, а не должно игнорироваться и заменяться нулями принудительно).
	 * Если что не так, возвращаем код ошибки
	 */
	if (msg.command == 3 /* установка параметров */
		&& msg.status == 0) return FSTATUS_WRONGSPC;

	if (msg.command == 9 /* установка параметров */
		&& msg.volume != 0) return FSTATUS_WRONGSPC;

	/*
	 * Запись параметров в буфер
	 */

	/* вспомогательный указатель */
	uint8* ptr = buf;
	unsigned char crc;

	/* маркер начала сообщения */
	*ptr = 0x1; ptr++;

	/* номер ТРК */
	*ptr = digToChar(msg.trkNo / 16, 16);
	crc = *ptr; ptr++;	/* первый байт при расчёте crc не учитывается, согласно протоколу */
	*ptr = digToChar(msg.trkNo % 16, 16);
	crc ^= *ptr; ptr++;

	/* код команды управления */
	*ptr = digToChar(msg.command, 16);
	crc ^= *ptr; ptr++;

	/* маркер начала поля данных */
	*ptr = 0x2;
	crc ^= *ptr; ptr++;

	unsigned int tmp;

	/* цена топлива */
	WRITE_TO_BUF(msg.price, tmp, PRC_LEN, ptr, crc, 10);

	/* объём дозы */
	WRITE_TO_BUF(msg.volume, tmp, VOL_LEN, ptr, crc, 10);

	/* поле статуса. Может использоваться при передачах от ККМ к ТРК */
	WRITE_TO_BUF(msg.status, tmp, STS_LEN, ptr, crc, 16);

	/* маркер окончания поля данных */
	*ptr = 0x3;
	crc ^= *ptr; ptr++;

	/* запись контрольной суммы. Вычисление можно сделать отдельным циклом, но предполагаем,
	 * что хотим слегка сэкономить на времени, и вычисляем по ходу записи в буфер. */
	*ptr = crc;

	return FSTATUS_OK;
}
