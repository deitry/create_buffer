/*
 * rs232_buffer.c
 *
 *  Created on: 5 окт. 2017 г.
 *      Author: dmsvo
 */

#include "rs232_buffer.h"

/* Вспомогательная функция по переводу цифры в ASCII. Подходит для цифр с основанием не больше 16.
 * Поскольку цифру в буквенный код всегда можно перевести, никаких кодов ошибки не предполагаем,
 * для удобства результат возвращаем как положено, а не через входные аргументы.
 * Если на вход поступает число, а не цифра, берём от него строго последнюю (ну, в смысле, первую) цифру в данном основании. */
char digToChar(int num, char base)
{
	/* убеждаемся, что перед нами строго цифра */
	char dig = num % base;

	if ((dig >= 0) && (dig <= 9))
	{
		return NUM0 + dig;
	}

	if ((dig >=10) && (dig <= 15))
	{
		return DIFA + dig; /* с 41го символа начинается A, B, ... , F; 0x41 - 0xA = 0x37*/
	}

	return FSTATUS_NOTDIGIT;	/* если каким-то образом нам не подошло */
}

/* Макрос для записи числа в буфер в десятеричном формате.
 * Для разнообразия, выполнено в виде макроса, а не функции.
 * Переводим число в ascii в обратном порядке для сравнительной лаконичности преобразования */
#define WRITE_TO_BUF_DEC(_var, _tmp, _len, _ptr, _crc)		\
{													\
	(_tmp) = (_var);								\
	for (int i = 0; i < (_len); i++)				\
	{												\
		(_ptr)[(_len)-i-1] = digToChar((_tmp),10); 	\
		(_crc) ^= (_ptr)[(_len)-i-1];				\
		(_tmp) = (_tmp) / 10;						\
	}												\
	(_ptr) += (_len);								\
}

/* Макрос для записи числа в буфер в шестнадцатиричном формате.
 * Для разнообразия, выполнено в виде макроса, а не функции.
 * Переводим число в ascii в обратном порядке для сравнительной лаконичности преобразования */
#define WRITE_TO_BUF_HEX(_var, _tmp, _len, _ptr, _crc)		\
{													\
	(_tmp) = (_var);								\
	for (int i = 0; i < (_len); i++)				\
	{												\
		(_ptr)[(_len)-i-1] = digToChar((_tmp),16); 	\
		(_crc) ^= (_ptr)[(_len)-i-1];				\
		(_tmp) = (_tmp) / 16;						\
	}												\
	(_ptr) += (_len);								\
}

/*
 * Функция принимает необходимые числа и составляет буфер по правилам протокола Искра
 * формат сообщения - список полей
 * наименование - размер
 * SOH - 1 байт - маркер начала
 * + TRK_No - 2 байта - номер ТРК
 * + Command - 1 байт - код команды управления
 * STX - 1 байт - маркер начала поля данных
 * + Price 6 - байт - цена топлива, коп
 * + Volume - 6 байт - доза налива
 * Status - 4 байта - код состояния/ошибки
 * ETX - 1 байт - маркер окончания поля данных
 * CRC - 1 байт - контрольная сумма
 * всего - 23 байта
 */
int fill_buffer (uint8* buf, struct Message msg)
{
	/*
	 * Проверка на то, что значения параметров в заданных границах
	 */
	if (msg.trkNo > 127) return FSTATUS_BOUND;
	if (msg.command < 1 || msg.command > 9 || msg.command == 2 || msg.command == 8) return FSTATUS_BOUND;
		/* дополнительно проверка на исключённые из протокола команды 2 и 8.
		 * Надо ли? Не могу сказать точно, не имея представления об эксплуатационной практике */
	if (msg.price > 999999 || msg.price < 0) return FSTATUS_BOUND;
	if (msg.volume > 999999 || msg.price < 0) return FSTATUS_BOUND;

	/*
	 * Тут должны быть дополнительные проверки для обеспечения корректности параметров для всех специальных случаев.
	 * Для примера, приведена проверка на наличие поля статуса для команды #3 ("Установка") (- предполагаем, что
	 * для данной команды в этом поле должно быть хоть что-то, чтобы команда отработала)
	 * и проверка на равенство 0 объёма дозы для команды #9 ("До полного бака") (- предполагаем, что это значение
	 * так же передаётся как входной параметр, а не должно игнорироваться и заменяться нулями принудительно).
	 * Если что не так, возвращаем код ошибки
	 */
	if (msg.command == 3 /* установка параметров */
		&& msg.status == 0) return FSTATUS_WRONGSPC;

	if (msg.command == 9 /* установка параметров */
		&& msg.volume != 0) return FSTATUS_WRONGSPC;

	/*
	 * Запись параметров в буфер
	 */

	/* вспомогательный указатель */
	uint8* ptr = buf;
	int crc;
	/* маркер начала сообщения */
	*ptr = 0x1; ptr++;

	/* номер ТРК */
	*ptr = digToChar(msg.trkNo / 16, 16);
	crc = *ptr; ptr++;	/* первый байт при расчёте crc не учитывается, согласно протоколу */
	*ptr = digToChar(msg.trkNo % 16, 16);
	crc ^= *ptr; ptr++;

	/* код команды управления */
	*ptr = digToChar(msg.command, 16);
	crc ^= *ptr; ptr++;

	/* маркер начала поля данных */
	*ptr = 0x2;
	crc ^= *ptr; ptr++;

	int tmp;

	/* цена топлива */
	WRITE_TO_BUF_DEC(msg.price, tmp, PRC_LEN, ptr, crc);

	/* объём дозы */
	WRITE_TO_BUF_DEC(msg.volume, tmp, VOL_LEN, ptr, crc);

	/* поле статуса. Может использоваться при передачах от ККМ к ТРК */
	WRITE_TO_BUF_HEX(msg.status, tmp, STS_LEN, ptr, crc);

	/* маркер окончания поля данных */
	*ptr = 0x3;
	crc ^= *ptr; ptr++;

	/* запись контрольной суммы. Вычисление можно сделать отдельным циклом, но предполагаем,
	 * что хотим слегка сэкономить на времени, и вычисляем по ходу записи в буфер. */
	*ptr = crc;

	return FSTATUS_OK;
}
