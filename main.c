/*
 * main.c
 *
 *  Created on: 5 окт. 2017 г.
 *      Author: dmsvo
 */

#include "rs232_buffer.h"

#ifdef DEBUG

/* Подключаем stdio для вывода в консоль конечного буфера для отладки и не подключаем в "релизном" варианте */
#include "stdio.h"

#endif

/* Вспомогательная функция. Преобразует строку ASCII в число по заданному основанию
 * Результат возвращаем через входные аргументы, чтобы можно было вернуть код отработки функции */
int charToDigit(char* str, unsigned char base, unsigned int* result)
{
	if (base > 16) return FSTATUS_WRONGIN;	/* Чтобы не хотелось странного */
		/* Теоретически, остаётся возможность произвольно выбрать основание числа не больше 16,
		 * но делать лишние проверки, чтобы это исключить, как-то нецелесообразно */

	*result = 0;	/* инициализируем */

	while (*str != '\0')
	{
		/* цифра */
		if (*str >= NUM0 && *str <= NUM9)
		{
			*result = (*result)*base + *str - NUM0;
		}
		else if (*str >= NUMA && *str <= NUMF && ((*str - DIFA) < base))
		/* A..F. Строчные буквы не принимаем */
		{
			*result = (*result)*base + *str - DIFA;
		}
		else
		/* если что-то отличное от хекс-цифры */
			return FSTATUS_WRONGIN;
		str++;
	}

	return FSTATUS_OK;
}

/*
 * Основная функция, чтобы можно было запустить.
 * В рабочем проекте её объявление скорее всего будет с фиксированными полями.
 * Строки входных параметров для примера:
 * "7F 1 4620 999999 FAFA", код завершения 0 // FSTATUS_OK // пример выходного буфера "7F1004620999999FAFAA"
 * "7F 1 4620 999999", 		код завершения 0 // FSTATUS_OK
 * "7F 1 4620", 			код завершения 1 // FSTATUS_WRONGCNT
 * "7G 1 4620 999999", 		код завершения 2 // FSTATUS_WRONGIN
 * "7F 1 462F 999999", 		код завершения 2 // FSTATUS_WRONGIN
 * "7F 1 4620 9999999",		код завершения 3 // FSTATUS_BOUND
 * "F0 1 4620 999999", 		код завершения 3 // FSTATUS_BOUND
 * "7F 3 4620 999999", 		код завершения 4 // FSTATUS_WRONGSPC
 */
int main (int argc, char* argv[])
{
	/*
	 * проверка на количество аргументов - считаем, что их должно быть 4 или 5 (argc на 1 больше)
	 * (значение для статуса полагаем опциональным, потому что для передачи от ККМ
	 * он используется в сравнительно редких случаях).
	 * Проверка на корректность данных будет осуществляться в функции наполнения буфера.
	 * В реальной функции (не main) скорее всего входные поля будет фиксированными и такая проверка не понадобится
	 */
	if (argc < INPUT_CNT + 1 || argc > INPUT_CNT + 2) return FSTATUS_WRONGCNT;

	/* объявление структуры, в которой будем содержать данные */
	struct Message message;
	int status;	// для запоминания статуса выполнения функции

	/* инициализируем переменные.
	 * Если функция парсинга возвращает что-то, отличное от нуля, значит со входными данными что-то не то. */
	if ((status = charToDigit(argv[1], 16, &(message.trkNo))) 	!= FSTATUS_OK) 	return status;	/* номер ТРК */
	if ((status = charToDigit(argv[2], 16, &(message.command))) != FSTATUS_OK) 	return status;	/* номер команды */
	if ((status = charToDigit(argv[3], 10, &(message.price))) 	!= FSTATUS_OK) 	return status;	/* цена */
	if ((status = charToDigit(argv[4], 10, &(message.volume))) 	!= FSTATUS_OK) 	return status;	/* объём дозы */

	if (argc == INPUT_CNT + 2)
	{
		if ((status = charToDigit(argv[5], 16, &(message.status))) != FSTATUS_OK) return status;	/* значение для поля "статус", если есть */
	}
	else
	{
		message.status = 0;	/* если не указан, на всякий случай принудительно инициализируем */
			/* Если указан - запоминаем, хотя в большинстве случаев он ничего не делает, игнорируем */
	}

	/*
	 * Предполагаем, что одного буфера нам будет достаточно и для отправки нового сообщения
	 * будем использовать его же, перезаписывая данные.
	 * Без применения динамического выделения памяти, массив под буфер должен быть объявлен вне функции, в которой формируется
	 * - или в качестве глобальной переменной, или, как здесь, в той функции, которая предполагает его использование
	 */
	uint8 message_buf[MESSAGE_LENGTH+1]; /* в самый последний байт на всякий случай пишем 0, чтобы выводилось нормально. */
		/* В рабочих условиях можно будет последний байт исключить */

	/* Инициализация */
	for (uint8* ptr = message_buf; ptr < message_buf + MESSAGE_LENGTH + 1; ptr++)
	{
		*ptr = '\0';
	}

	/* заполнение буфера */
	status = fill_buffer (&message_buf[0], message);
	if (status != FSTATUS_OK)
		return status;

#ifdef DEBUG
	/* использование буфера - ради проверки выводим на экран */
	puts(message_buf);

#endif

	return FSTATUS_OK;
}
